<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - geometry LatheGeometry</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <meta name="author" content="Vildanov Almaz" />
    <style>
      body {
        color: #000;
        font-family: Monospace;
        font-size: 13px;
        text-align: center;
        font-weight: bold;

        /* background-color: #fff; */
        margin: 0px;
        overflow: hidden;
      }

      canvas {
        display: block;
        width: 550px !important;
        height: 550px !important;
        border: 2px solid;
      }
    </style>
  </head>

  <body>
    <div id="container"></div>

    <!-- <input type="number" name="" id="topWidth" placeholder="Enter top width" /> -->

    <script src="js/three.min.js"></script>

    <script>
      // Define the PrismGeometry constructor
      function PrismGeometry(vertices, height) {
        var Shape = new THREE.Shape();

        (function f(ctx) {
          ctx.moveTo(vertices[0].x, vertices[0].y);
          for (var i = 1; i < vertices.length; i++) {
            ctx.lineTo(vertices[i].x, vertices[i].y);
          }
          ctx.lineTo(vertices[0].x, vertices[0].y);
        })(Shape);

        var settings = {
          amount: height,
          bevelEnabled: false,
        };

        THREE.ExtrudeGeometry.call(this, Shape, settings);
      }

      PrismGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);

      // below this function for  control
      createPrism(12, 15, 30, 20, 6);

      function createPrism(thickness, length, bottomWidth, topWidth, edge) {
        // camera
        AddCamera(-40, 50, 200);

        scene = new THREE.Scene();

        // lights

        light = new THREE.DirectionalLight(0xffffff, 1 / 2);
        light.position.set(0, 300, 500);
        scene.add(light);

        light = new THREE.DirectionalLight(0xffffff, 1 / 2);
        light.position.set(-100, 30, 0);
        scene.add(light);

        // renderer

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setClearColor(0xffffff);
        renderer.setSize(window.innerWidth, window.innerHeight);

        container = document.getElementById("container");
        container.appendChild(renderer.domElement);

        window.addEventListener("resize", onWindowResize, false);

        var material = new THREE.MeshPhongMaterial({
          color: 0x00b2fc,
          specular: 0x00ffff,
          shininess: 20,
        });

        //   var geometry = new PrismGeometry([A, B, C, D, E, F], height);
        var geometry = new PrismGeometry(
          vectorFun(length, bottomWidth, topWidth, edge),
          thickness
        );

        var prism2 = new THREE.Mesh(geometry, material);

        scene.add(prism2);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      renderer.render(scene, camera);
      function AddCamera(X, Y, Z) {
        camera = new THREE.PerspectiveCamera();
        camera.position.set(-10, 25, 100);
        camera.rotation.x = -0.2;
        camera.rotation.y = -0.3;
        camera.rotation.z = -0.04;
      }

      //
      // let defaultTopWidthValue = Number(
      //   document.querySelector("#top_width").defaultValue
      // );
      function validationTopWidthAndEdge(
        bottomWidth,
        topWidth,
        inputId,
        defaultValue,
        message
      ) {
        const getWidth = eval(bottomWidth);
        let getTopWidth = eval(topWidth);

        let getInput = document.getElementById(`${inputId}`);

        const getFinalTopWidth =
          getInput.value >= 8 && getWidth >= 8
            ? getInput.value - 2
            : getTopWidth;

        if (getTopWidth > getWidth) {
          getInput.style.border = "2px solid red";

          getInput.value = getTopWidth;

          alert(`The ${message} is too large.`);
        } else {
          getInput.style.border = "1px solid #8c8f94";
          getInput.value = getFinalTopWidth;
        }
      }

      validationTopWidthAndEdge(8, 8, "topWidth", 15, "top width");

      function vectorFun(length, bottomWidth, topWidth, edge) {
        // get default values

        let defaultLength = 30;
        let defaultWidth = 30;
        let defaultTopWidth = 22;
        let defaultEdge = 7.5;

        let getIncreaseLength = length - defaultLength;
        let getIncreaseTopWidth = topWidth - defaultTopWidth;
        let getIncreaseWidthVal = bottomWidth - defaultWidth;

        let getIncreaseEdge = edge - defaultEdge;

        //

        let bottomWidthDividedByTwo = bottomWidth / 2;

        //
        let bX = bottomWidth;
        let bY = 0;

        let cX = 30;
        let cY = edge || defaultWidth / 2 / 2;

        let dX = topWidth || defaultTopWidth;
        let dY = length;

        let eX = edge || defaultWidth / 2 / 2;
        let eY = length;

        let fX = 0;
        let fY = edge || defaultWidth / 2 / 2;

        let A = new THREE.Vector2(-getIncreaseWidthVal / 2, 0);
        let B = new THREE.Vector2(bX - getIncreaseWidthVal / 2, bY);
        let C = new THREE.Vector2(cX + getIncreaseWidthVal / 2, cY);
        let D = new THREE.Vector2(dX - getIncreaseTopWidth / 2, dY);
        let E = new THREE.Vector2(
          eX - getIncreaseTopWidth / 2 - getIncreaseEdge / 2,
          eY
        );
        let F = new THREE.Vector2(-getIncreaseWidthVal / 2, fY);

        console.log({ A, B, C, D, E, F });

        return [A, B, C, D, E, F];
      }
    </script>
  </body>
</html>
